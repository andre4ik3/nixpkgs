{ config, pkgs, lib, ... }:

let
  cfg = config.services.pcp;

  pcpEnvironment = let
    # Read the compiled default environment variables from the PCP package,
    # using PCP's own `pcp.env` script.
    defaultVars = let
      envFile = pkgs.runCommand "env.json" {
        PCP_CONF = "${cfg.package}/etc/pcp.conf";
      } ''
        . "${cfg.package}/etc/pcp.env"
        "${lib.getExe pkgs.jq}" -n env > $out
      '';
      envJSON = builtins.unsafeDiscardStringContext (builtins.readFile envFile);
      envVars = builtins.fromJSON envJSON;
      pcpVars = lib.filterAttrs (n: v: lib.hasPrefix "PCP_" n) envVars;
    in pcpVars;

    # Write using a simple key-value format, as outlined in PCP's own
    # documentation (see `pcp.conf(5)`). Quoting is neither necessary nor
    # supported -- `pcp.env` will automatically quote everything after `=`.
    toKeyValue = lib.generators.toKeyValue {};
  in pkgs.writeText "pcp.conf" ''
    # This file is generated by Nix. Do not edit!
    # Instead, configure PCP environment variables through the
    # `services.pcp.extraEnvironment` NixOS option.

    ${toKeyValue (defaultVars // cfg.extraEnvironment)}
  '';

  # Converts the option form of the equivalence map into the list form. For
  # each key-value pair (where key is a string, and value is an array of
  # strings), the "elements" (key + value) are all set to equal to each other,
  # and this operation is repeated until two successive iterations produce the
  # same result. Finally, the "elements" are returned as a unique list of
  # equivalent strings (list of list of strings).
  equivalenceMap = let
    graph = lib.attrsToList cfg.equivalentInstanceDomains;
    normalize = graph': lib.foldl' (
      graph: { name, value }: let
        members = [ name ] ++ value;
        newMembers = lib.map ({ name, value }: let
          isMember = (builtins.elem name members) || (builtins.length (lib.intersectLists members value) != 0);
          newList = lib.unique (members ++ [ name ] ++ value);
        in {
          inherit name;
          value = if isMember then newList else value;
        }) graph;
      in newMembers
    ) graph' graph';
    recurseUntilDone = graph: let
      normalized = normalize graph;
      isDone = normalized == graph;
      next = if isDone then lib.id else recurseUntilDone;
    in next normalized;
    finalElements = lib.unique (lib.map (x: x.value) (recurseUntilDone graph));
  in finalElements;

  pcpEquivalenceMap = pkgs.writeText "indom.conf" ''
    # This file is generated by Nix. Do not edit!
    # Instead, configure the Instance Domain Equivalence Map through the
    # `services.pcp.equivalentInstanceDomains` NixOS option.

    ${lib.concatMapStringsSep "\n" (lib.concatStringsSep " ") equivalenceMap}
  '';
in

{
  # imports = [
  #   ./interpreters.nix
  #   ./pmcd.nix
  #   ./pmda.nix
  #   ./pmie.nix
  #   ./pmlogger.nix
  #   ./pmproxy.nix
  # ];

  options.services.pcp = {
    enable = lib.mkEnableOption "the Performance Co-Pilot system performance analysis toolkit";
    package = lib.mkPackageOption pkgs "pcp" { };

    equivalentInstanceDomains = lib.mkOption {
      type = with lib.types; attrsOf (listOf str);
      default = { };
      example = lib.literalExpression ''
        {
          "3.9" = [ "3.39" "3.40" ];
          "60.0" = [ "127.*" ];
        }
      '';
      description = ''
        The instance domains that are semantically (and syntactically)
        equivalent. Each instance domain is specified using the
        `‹domain›.‹serial›` notation, as reported by {command}`pminfo -d`.
        `‹serial›` may be `*` to indicate *all* instance domains for the
        associated domain.
      '';
    };

    extraEnvironment = lib.mkOption {
      type = with lib.types; let
        atom = oneOf [ int str bool ];
      in attrsOf (coercedTo atom builtins.toString str);
      default = { };
      description = ''
        Additional environment variables to add to `pcp.conf`. All variable
        names must begin with `PCP_`, as otherwise the variable won't be
        processed by the PCP environment configuration script (`pcp.env`).
      '';
    };
  };

  config = lib.mkIf cfg.enable {
    assertions = lib.singleton (let
      names = lib.attrNames cfg.extraEnvironment;
      splitNames = lib.partition (lib.hasPrefix "PCP_") names;
      wrongNames = lib.concatStringsSep ", " splitNames.wrong;
    in {
      assertion = builtins.length splitNames.wrong == 0;
      message = ''
        services.pcp.extraEnvironment: The following PCP environment variables
        are not prefixed with `PCP_`. This means that they would be ignored by
        PCP's environment source script and not be set. Please correct this by
        prefixing the environment variables with `PCP_`, or alternatively use
        other NixOS options to set unprefixed variables.

        ${wrongNames}
      '';
    });

    environment.systemPackages = [ cfg.package ];
    systemd.packages = [ cfg.package ];

    systemd.tmpfiles = {
      # Creates the `/var/log/pcp` and `/var/lib/pcp` directory structures
      packages = [ cfg.package ];

      rules = [
        # Ensure correct permissions on the top-level directories
        "d  /var/lib/pcp                 755 root root -"
        "d  /var/lib/pcp/pmcd            700 root root -"

        # Set up the necessary temporary directories
        "d  /var/lib/pcp/tmp/bash        755 pcp  pcp  -"
        "d  /var/lib/pcp/tmp/json        755 pcp  pcp  -"
        "d  /var/lib/pcp/tmp/mmv         755 pcp  pcp  -"
        "d  /var/lib/pcp/tmp/pmie        755 pcp  pcp  -"
        "d  /var/lib/pcp/tmp/pmlogger    755 pcp  pcp  -"
        "d  /var/lib/pcp/tmp/pmproxy     755 pcp  pcp  -"

        # Fix permissions for the config files
        "d  /var/lib/pcp/config          755 root root -"
        "d  /var/lib/pcp/config/pmda     775 pcp  pcp  -"
        "d  /var/lib/pcp/config/pmie     775 pcp  pcp  -"
        "d  /var/lib/pcp/config/pmlogger 775 pcp  pcp  -"
      ];
    };

    users = {
      users.pcp = {
        isSystemUser = true;
        group = "pcp";
        home = "/var/lib/pcp";
        description = "Performance Co-Pilot";
      };
      groups.pcp = { };
    };

    # Default equivalence map shipped with PCP
    services.pcp.equivalentInstanceDomains = {
      "3.9" = [ "3.39" "3.40" ];
      "60.0" = [ "127.*" ];
    };

    environment.etc = {
      # Utility script that provides some functions and exports the variables
      # from `pcp.conf`. Adds a small header with `gawk` and `gnused`, as the
      # script requires them.
      "pcp.env".text = ''
        export PATH="${
          lib.makeBinPath [ pkgs.gawk pkgs.gnused cfg.package ]
        }:$PATH"

        ${builtins.readFile "${cfg.package}/etc/pcp.env"}
      '';

      # Global configuration for all PCP programs
      "pcp.conf".source = pcpEnvironment;

      # Instance Domain equivalence map
      "pcp/indom.conf".source = pcpEquivalenceMap;

      # TODO: random bits and pieces that probably belong elsewhere
      "pcp/derived".source = "${cfg.package}/etc/pcp/derived";
      "pcp/pmlogconf".source = "${cfg.package}/etc/pcp/pmlogconf";
      "pcp/pmlogrewrite".source = "${cfg.package}/etc/pcp/pmlogrewrite";
      "pcp/pmlogredact".source = "${cfg.package}/etc/pcp/pmlogredact";
      "pcp/pmchart".source = "${cfg.package}/etc/pcp/pmchart";
      "pcp/pmrep".source = "${cfg.package}/etc/pcp/pmrep";
      "pcp/pmafm".source = "${cfg.package}/etc/pcp/pmafm";
      "pcp/dstat".source = "${cfg.package}/etc/pcp/dstat";
      "pcp/pmsnap".source = "${cfg.package}/etc/pcp/pmsnap";
      "pcp/labels.conf".source = "${cfg.package}/etc/pcp/labels.conf";
      "pcp/tls.conf".source = "${cfg.package}/etc/pcp/tls.conf";
    };

    # Set up integrations with other services
    environment.etc."sasl2/pmcd.conf".source = "${cfg.package}/etc/sasl2/pmcd.conf";
    services.zabbixAgent.modules."zbxpcp.so" = config.package;
  };

  meta = {
    maintainers = with lib.maintainers; [ andre4ik3 ];
    doc = ./pcp.md;
  };
}
